{"meta":{"title":"CNsixgod","subtitle":null,"description":null,"author":"sixgod","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2018-11-07T10:11:10.000Z","updated":"2018-11-07T10:11:54.872Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-12-11T14:11:35.000Z","updated":"2018-12-11T14:13:24.971Z","comments":true,"path":"categories/index-1.html","permalink":"http://yoursite.com/categories/index-1.html","excerpt":"","text":""},{"title":"categories","date":"2018-11-07T10:12:05.000Z","updated":"2018-11-07T10:12:27.786Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"mysql优化","slug":"mysql-youhua","date":"2018-12-12T14:19:29.262Z","updated":"2018-12-12T14:19:17.411Z","comments":true,"path":"2018/12/12/mysql-youhua/","link":"","permalink":"http://yoursite.com/2018/12/12/mysql-youhua/","excerpt":"","text":"mysql优化msyql优化方向 存储层 存储引擎 列类型 范式 设计层 索引 缓存 分表 sql层 效率高的sql语句 架构层 分布式数据库架构 主从同步 存储引擎 myisam 物理文件 .frm 结构文件 .MYD 数据文件 .MYI 索引文件 存储顺序 存储顺序为插入顺序 没有排序 复制备份，压缩机制 移动三个物理文件即可备份恢复 压缩： 节省空间，查询快速(表压缩之后无法进行写入操作,压缩表机制，适合读比较多的场景使用) Mysql\\bin myisamchk.exe – 重建索引及解压缩 myisampack.exe –压缩 cmd &gt; D:\\phpstudy\\Mysql\\bin\\myisampack.exe D:\\phpstudy\\Mysql\\data\\student myisamchk.exe –重建索引 cmd &gt; D:\\phpstudy\\Mysql\\bin\\myisamchk.exe -rq D:\\phpstudy\\Mysql\\data\\student myisamchk.exe –解压缩(压缩操作需要进行表的索引重建，但是解压不需要了，会自动重建。) cmd &gt; D:\\phpstudy\\Mysql\\bin\\myisamchk.exe –unpack D:\\phpstudy\\Mysql\\data\\student 并发性： 表级锁（并发写入） 并发性稍弱，只有表锁 相关链接 innodb 物理文件 .frm 结构文件 数据库的所有innodb数据和索引文件都放在data/ibdata1文件中 存储顺序 存储顺序为数据主键顺序 复制备份 需要导出sql文件，再导入进行备份和恢复操作 所以需要进行innodb表数据结构的分开存储操作 mysql &gt; show variables like ‘innodb_file_per_table’; //查看innodb存储状态 value off 关闭 mysql &gt; set global innodb_file_per_table=1; //临时修改值为开启 value on 开启 建表后数据索引文件就分离 ibdata1了 重启后建表数据还是在一起，但是分开后的就不会再连一起了 xxx.ibd文件–数据和索引文件 并发性： 擅长并发 更适合并发写入，并发写中，为了防止数据不一致 使用锁机制 有更小的锁表粒度,行级别 如何选择myisam innodb 根据引擎的特点进行选择 功能性上，快速备份恢复myisam；事务和外键，选择innodb 一般使用myisam，cms（内容管理系统） innodb适合使用在抢购功能，订单功能，并发写入较多 字段选取 age 用tinyint 乌龟年龄 smallint 表数据不超过1600w+ 使用mediumint 内容长度 char(255) 固定字符 不足null补齐 varchar(65535) 如果是UTF则最大65535/3 - 1个字符，因为要预留空间存放该字段的字符数目) 加密密码 手机号 char 邮箱 varchar char查询的效率比varchar高 整型存储 尽量使用整型存储其他数据的类型。节省空间提高查询速度 时间戳 使用int来存储时间。4字节 mysql里的时间戳函数 unix_timestamp() 当前时间戳信息 from_unixtime() 读取一个时间戳信息 php用date()转换 int类型 时间的比较直接比大小就行了 使用int存储IP 计算范围更加方便 mysql: inet_aton(ip) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inet_ntoa(int) php: ip2long(ip)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long2ip(ip) 范式 第一范式 列类型具有原子性，每列(或者每个属性)都是不可再分的最小数据单元(也称为最小的原子单元) 第二范式 数据具有唯一性 设置主键 第三范式 数据字段和主键具有紧密联系/直接关系，不能够有冗（rong）余[重复]数据 1NF&lt;2NF&lt;3NF，范式是一层层满足的 逆范式&nbsp;&nbsp;一般情况下，设计的表结构符合三范式，被认为是良好的数据机构设计。但是，在很多实际业务场景下，为了能够提高数据表的查询速度，要建立使用冗（rong）余字段。也就不符合第三范式了。为了整 第三范式。之前的查询学生的所有信息（包含系别信息），需要进行连表操作。连表操作，遍历最大数为笛卡尔积（相乘）。可以修改表机构为如下，建立冗余字段。 建立冗余字段之后，查询变快。在修改和维护数据时，要同时维护冗余字段。保持数据的一致性 索引索引优化","categories":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"}],"tags":[]},{"title":"MYSQL 索引","slug":"mysql","date":"2018-12-11T14:04:52.465Z","updated":"2018-12-11T14:29:38.773Z","comments":true,"path":"2018/12/11/mysql/","link":"","permalink":"http://yoursite.com/2018/12/11/mysql/","excerpt":"","text":"MYSQL 索引 索引的好处： 20多条数据源随机生成200万条数据，平均每条数据源都重复大概10万次，表结构比较简单，仅包含一个自增ID，一个char类型，一个text类型和一个int类型，单表2G大小，使用MyIASM引擎。开始测试未添加任何索引。执行下面的SQL语句： mysql&gt; SELECT id,FROM_UNIXTIME(time) FROM article WHERE a.title=’测试标题’ 查询需要的时间非常恐怖的，如果加上联合查询和其他一些约束条件，数据库会疯狂的消耗内存，并且会影响前端程序的执行。这时给title字段添加一个BTREE索引： mysql&gt; ALTER TABLE article ADD INDEX index_article_title ON title(200); 再次执行上述查询语句，其对比非常明显 测试是否使用了索引进行查询 1explain select * from table where xxx=1; explain 关键字 普通索引1234567891011121314create INDEX index_name ON table(column(length))//直接创建ALTER TABLE table_name ADD INDEX index_name ON (column(length))//修改表结构create table tablename( id int not null, name varchar(255) not null, KEY(name) //index() 也行);//创建表的时候同时创建---删除索引drop INDEX index_name ON table(column(length)) 2.唯一索引1234567891011create UNIQUE INDEX index_name ON table(column(length))//直接创建ALTER TABLE table_name ADD UNIQUE index_name ON (column(length))//修改表结构create table tablename( id int not null, name varchar(255) not null, UNIQUE INDEX index_name(id));//创建表的时候同时创建 3.主键索引1primary key(id) 4.组合索引 解释最左前缀 组合索引就是遵从了最左前缀，利用索引中最左边的列集来匹配行，这样的列集称为最左前缀，不明白没关系，举几个例子就明白了，例如，这里由id、name和age3个字段构成的索引，索引行中就按id/name/age的顺序存放，索引可以索引下面字段组合(id，name，age)、(id，name)或者(id)。如果要查询的字段不构成索引最左面的前缀，那么就不会是用索引，比如，age或者（name，age）组合就不会使用索引查询 1234567create table tablename( id int not null, name varchar(255) not null, age int not null, index index_name(id,name,age)); 5.创建全文索引 全文索引可以用于全文搜索，但只有MyISAM存储引擎支持FULLTEXT索引，并且只为CHAR、VARCHAR和TEXT列服务。索引总是对整个列进行，不支持前缀索引， 12345678create table tablename( id int not null, name varchar(255) not null, age int not null, info varchar(255) not null, FULLTEXT INDEX index_name(info)); 注意：在使用全文搜索时，需要借助MATCH函数，并且其全文搜索的限制比较多，比如只能通过MyISAM引擎，比如只能在CHAR,VARCHAR,TEXT上设置全文索引。比如搜索的关键字默认至少要4个字符，比如搜索的关键字太短就会被忽略掉。等等，如果你们在实验的时候可能会实验不出来。感兴趣的同学可以看看这篇文章全文搜索的使用- 索引的优化 索引不会包含有NULL值得列 只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。2.","categories":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"}],"tags":[]}]}