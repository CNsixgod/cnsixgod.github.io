{"meta":{"title":"CNsixgod","subtitle":null,"description":null,"author":"sixgod","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-12-11T14:11:35.000Z","updated":"2018-12-11T14:13:24.971Z","comments":true,"path":"categories/index-1.html","permalink":"http://yoursite.com/categories/index-1.html","excerpt":"","text":""},{"title":"categories","date":"2018-11-07T10:12:05.000Z","updated":"2018-11-07T10:12:27.786Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-11-07T10:11:10.000Z","updated":"2018-11-07T10:11:54.872Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MYSQL 索引","slug":"mysql","date":"2018-12-11T14:04:52.465Z","updated":"2018-12-11T14:29:38.773Z","comments":true,"path":"2018/12/11/mysql/","link":"","permalink":"http://yoursite.com/2018/12/11/mysql/","excerpt":"","text":"MYSQL 索引 索引的好处： 20多条数据源随机生成200万条数据，平均每条数据源都重复大概10万次，表结构比较简单，仅包含一个自增ID，一个char类型，一个text类型和一个int类型，单表2G大小，使用MyIASM引擎。开始测试未添加任何索引。执行下面的SQL语句： mysql&gt; SELECT id,FROM_UNIXTIME(time) FROM article WHERE a.title=’测试标题’ 查询需要的时间非常恐怖的，如果加上联合查询和其他一些约束条件，数据库会疯狂的消耗内存，并且会影响前端程序的执行。这时给title字段添加一个BTREE索引： mysql&gt; ALTER TABLE article ADD INDEX index_article_title ON title(200); 再次执行上述查询语句，其对比非常明显 测试是否使用了索引进行查询 1explain select * from table where xxx=1; explain 关键字 普通索引1234567891011121314create INDEX index_name ON table(column(length))//直接创建ALTER TABLE table_name ADD INDEX index_name ON (column(length))//修改表结构create table tablename( id int not null, name varchar(255) not null, KEY(name) //index() 也行);//创建表的时候同时创建---删除索引drop INDEX index_name ON table(column(length)) 2.唯一索引1234567891011create UNIQUE INDEX index_name ON table(column(length))//直接创建ALTER TABLE table_name ADD UNIQUE index_name ON (column(length))//修改表结构create table tablename( id int not null, name varchar(255) not null, UNIQUE INDEX index_name(id));//创建表的时候同时创建 3.主键索引1primary key(id) 4.组合索引 解释最左前缀 组合索引就是遵从了最左前缀，利用索引中最左边的列集来匹配行，这样的列集称为最左前缀，不明白没关系，举几个例子就明白了，例如，这里由id、name和age3个字段构成的索引，索引行中就按id/name/age的顺序存放，索引可以索引下面字段组合(id，name，age)、(id，name)或者(id)。如果要查询的字段不构成索引最左面的前缀，那么就不会是用索引，比如，age或者（name，age）组合就不会使用索引查询 1234567create table tablename( id int not null, name varchar(255) not null, age int not null, index index_name(id,name,age)); 5.创建全文索引 全文索引可以用于全文搜索，但只有MyISAM存储引擎支持FULLTEXT索引，并且只为CHAR、VARCHAR和TEXT列服务。索引总是对整个列进行，不支持前缀索引， 12345678create table tablename( id int not null, name varchar(255) not null, age int not null, info varchar(255) not null, FULLTEXT INDEX index_name(info)); 注意：在使用全文搜索时，需要借助MATCH函数，并且其全文搜索的限制比较多，比如只能通过MyISAM引擎，比如只能在CHAR,VARCHAR,TEXT上设置全文索引。比如搜索的关键字默认至少要4个字符，比如搜索的关键字太短就会被忽略掉。等等，如果你们在实验的时候可能会实验不出来。感兴趣的同学可以看看这篇文章全文搜索的使用- 索引的优化 索引不会包含有NULL值得列 只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。2.","categories":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-11-07T09:28:42.735Z","updated":"2018-11-07T09:28:42.735Z","comments":true,"path":"2018/11/07/hello-world/","link":"","permalink":"http://yoursite.com/2018/11/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}